// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 12 Dec 2023 23:18:54 CET.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ug

/*
#cgo LDFLAGS: -L../ugui/build -lugui
#include "../ugui/ugui.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocUG_FONTMemory allocates memory for type C.UG_FONT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_FONTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_FONTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_FONTValue = unsafe.Sizeof([1]C.UG_FONT{})

// copyPUcharBytes copies the data from Go slice as *C.uchar.
func copyPUcharBytes(slice *sliceHeader) (*C.uchar, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUcharValue) * slice.Len,
		Cap:  int(sizeOfUcharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uchar)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocUcharMemory allocates memory for type C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUcharValue = unsafe.Sizeof([1]C.uchar{})

// copyPUG_U8Bytes copies the data from Go slice as *C.UG_U8.
func copyPUG_U8Bytes(slice *sliceHeader) (*C.UG_U8, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUG_U8Value) * slice.Len,
		Cap:  int(sizeOfUG_U8Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UG_U8)(mem0), allocs
}

// allocUG_U8Memory allocates memory for type C.UG_U8 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_U8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_U8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_U8Value = unsafe.Sizeof([1]C.UG_U8{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_FONT) Ref() *C.UG_FONT {
	if x == nil {
		return nil
	}
	return x.ref83da41da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_FONT) Free() {
	if x != nil && x.allocs83da41da != nil {
		x.allocs83da41da.(*cgoAllocMap).Free()
		x.ref83da41da = nil
	}
}

// NewUG_FONTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_FONTRef(ref unsafe.Pointer) *UG_FONT {
	if ref == nil {
		return nil
	}
	obj := new(UG_FONT)
	obj.ref83da41da = (*C.UG_FONT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_FONT) PassRef() (*C.UG_FONT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref83da41da != nil {
		return x.ref83da41da, nil
	}
	mem83da41da := allocUG_FONTMemory(1)
	ref83da41da := (*C.UG_FONT)(mem83da41da)
	allocs83da41da := new(cgoAllocMap)
	allocs83da41da.Add(mem83da41da)

	var cp_allocs *cgoAllocMap
	ref83da41da.p, cp_allocs = copyPUcharBytes((*sliceHeader)(unsafe.Pointer(&x.P)))
	allocs83da41da.Borrow(cp_allocs)

	var cfont_type_allocs *cgoAllocMap
	ref83da41da.font_type, cfont_type_allocs = (C.FONT_TYPE)(x.Font_type), cgoAllocsUnknown
	allocs83da41da.Borrow(cfont_type_allocs)

	var cchar_width_allocs *cgoAllocMap
	ref83da41da.char_width, cchar_width_allocs = (C.UG_S16)(x.Char_width), cgoAllocsUnknown
	allocs83da41da.Borrow(cchar_width_allocs)

	var cchar_height_allocs *cgoAllocMap
	ref83da41da.char_height, cchar_height_allocs = (C.UG_S16)(x.Char_height), cgoAllocsUnknown
	allocs83da41da.Borrow(cchar_height_allocs)

	var cstart_char_allocs *cgoAllocMap
	ref83da41da.start_char, cstart_char_allocs = (C.UG_U16)(x.Start_char), cgoAllocsUnknown
	allocs83da41da.Borrow(cstart_char_allocs)

	var cend_char_allocs *cgoAllocMap
	ref83da41da.end_char, cend_char_allocs = (C.UG_U16)(x.End_char), cgoAllocsUnknown
	allocs83da41da.Borrow(cend_char_allocs)

	var cwidths_allocs *cgoAllocMap
	ref83da41da.widths, cwidths_allocs = copyPUG_U8Bytes((*sliceHeader)(unsafe.Pointer(&x.Widths)))
	allocs83da41da.Borrow(cwidths_allocs)

	x.ref83da41da = ref83da41da
	x.allocs83da41da = allocs83da41da
	return ref83da41da, allocs83da41da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_FONT) PassValue() (C.UG_FONT, *cgoAllocMap) {
	if x.ref83da41da != nil {
		return *x.ref83da41da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_FONT) Deref() {
	if x.ref83da41da == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.P))
	hxfc4425b.Data = unsafe.Pointer(x.ref83da41da.p)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Font_type = (FONT_TYPE)(x.ref83da41da.font_type)
	x.Char_width = (UG_S16)(x.ref83da41da.char_width)
	x.Char_height = (UG_S16)(x.ref83da41da.char_height)
	x.Start_char = (UG_U16)(x.ref83da41da.start_char)
	x.End_char = (UG_U16)(x.ref83da41da.end_char)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Widths))
	hxf95e7c8.Data = unsafe.Pointer(x.ref83da41da.widths)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

}

// allocUG_OBJECTMemory allocates memory for type C.UG_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_OBJECTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_OBJECTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_OBJECTValue = unsafe.Sizeof([1]C.UG_OBJECT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_OBJECT) Ref() *C.UG_OBJECT {
	if x == nil {
		return nil
	}
	return x.refc19e8ff4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_OBJECT) Free() {
	if x != nil && x.allocsc19e8ff4 != nil {
		x.allocsc19e8ff4.(*cgoAllocMap).Free()
		x.refc19e8ff4 = nil
	}
}

// NewUG_OBJECTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_OBJECTRef(ref unsafe.Pointer) *UG_OBJECT {
	if ref == nil {
		return nil
	}
	obj := new(UG_OBJECT)
	obj.refc19e8ff4 = (*C.UG_OBJECT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_OBJECT) PassRef() (*C.UG_OBJECT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc19e8ff4 != nil {
		return x.refc19e8ff4, nil
	}
	memc19e8ff4 := allocUG_OBJECTMemory(1)
	refc19e8ff4 := (*C.UG_OBJECT)(memc19e8ff4)
	allocsc19e8ff4 := new(cgoAllocMap)
	allocsc19e8ff4.Add(memc19e8ff4)

	var cstate_allocs *cgoAllocMap
	refc19e8ff4.state, cstate_allocs = (C.UG_U16)(x.State), cgoAllocsUnknown
	allocsc19e8ff4.Borrow(cstate_allocs)

	var ctouch_state_allocs *cgoAllocMap
	refc19e8ff4.touch_state, ctouch_state_allocs = (C.UG_U8)(x.Touch_state), cgoAllocsUnknown
	allocsc19e8ff4.Borrow(ctouch_state_allocs)

	var cupdate_allocs *cgoAllocMap
	refc19e8ff4.update, cupdate_allocs = x.Update.PassValue()
	allocsc19e8ff4.Borrow(cupdate_allocs)

	var ca_abs_allocs *cgoAllocMap
	refc19e8ff4.a_abs, ca_abs_allocs = x.A_abs.PassValue()
	allocsc19e8ff4.Borrow(ca_abs_allocs)

	var ca_rel_allocs *cgoAllocMap
	refc19e8ff4.a_rel, ca_rel_allocs = x.A_rel.PassValue()
	allocsc19e8ff4.Borrow(ca_rel_allocs)

	var c_type_allocs *cgoAllocMap
	refc19e8ff4._type, c_type_allocs = (C.UG_U8)(x._type), cgoAllocsUnknown
	allocsc19e8ff4.Borrow(c_type_allocs)

	var cid_allocs *cgoAllocMap
	refc19e8ff4.id, cid_allocs = (C.UG_U8)(x.Id), cgoAllocsUnknown
	allocsc19e8ff4.Borrow(cid_allocs)

	var cevent_allocs *cgoAllocMap
	refc19e8ff4.event, cevent_allocs = (C.UG_U8)(x.Event), cgoAllocsUnknown
	allocsc19e8ff4.Borrow(cevent_allocs)

	var cdata_allocs *cgoAllocMap
	refc19e8ff4.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsc19e8ff4.Borrow(cdata_allocs)

	var cfcs_state_allocs *cgoAllocMap
	refc19e8ff4.fcs_state, cfcs_state_allocs = (C.UG_U8)(x.Fcs_state), cgoAllocsUnknown
	allocsc19e8ff4.Borrow(cfcs_state_allocs)

	x.refc19e8ff4 = refc19e8ff4
	x.allocsc19e8ff4 = allocsc19e8ff4
	return refc19e8ff4, allocsc19e8ff4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_OBJECT) PassValue() (C.UG_OBJECT, *cgoAllocMap) {
	if x.refc19e8ff4 != nil {
		return *x.refc19e8ff4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_OBJECT) Deref() {
	if x.refc19e8ff4 == nil {
		return
	}
	x.State = (UG_U16)(x.refc19e8ff4.state)
	x.Touch_state = (UG_U8)(x.refc19e8ff4.touch_state)
	x.Update = *NewUG_OBJECT_UPDATERef(unsafe.Pointer(&x.refc19e8ff4.update))
	x.A_abs = *NewUG_AREARef(unsafe.Pointer(&x.refc19e8ff4.a_abs))
	x.A_rel = *NewUG_AREARef(unsafe.Pointer(&x.refc19e8ff4.a_rel))
	x._type = (UG_U8)(x.refc19e8ff4._type)
	x.Id = (UG_U8)(x.refc19e8ff4.id)
	x.Event = (UG_U8)(x.refc19e8ff4.event)
	x.Data = (unsafe.Pointer)(unsafe.Pointer(x.refc19e8ff4.data))
	x.Fcs_state = (UG_U8)(x.refc19e8ff4.fcs_state)
}

// allocUG_WINDOWMemory allocates memory for type C.UG_WINDOW in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_WINDOWMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_WINDOWValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_WINDOWValue = unsafe.Sizeof([1]C.UG_WINDOW{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSUG_OBJECT transforms a sliced Go data structure into plain C format.
func unpackSUG_OBJECT(x []UG_OBJECT) (unpacked *C.UG_OBJECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUG_OBJECTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.UG_OBJECT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.UG_OBJECT)(h.Data)
	return
}

// packSUG_OBJECT reads sliced Go data structure out from plain C format.
func packSUG_OBJECT(v []UG_OBJECT, ptr0 *C.UG_OBJECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUG_OBJECTValue]C.UG_OBJECT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUG_OBJECTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_WINDOW) Ref() *C.UG_WINDOW {
	if x == nil {
		return nil
	}
	return x.refe2d7ddc5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_WINDOW) Free() {
	if x != nil && x.allocse2d7ddc5 != nil {
		x.allocse2d7ddc5.(*cgoAllocMap).Free()
		x.refe2d7ddc5 = nil
	}
}

// NewUG_WINDOWRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_WINDOWRef(ref unsafe.Pointer) *UG_WINDOW {
	if ref == nil {
		return nil
	}
	obj := new(UG_WINDOW)
	obj.refe2d7ddc5 = (*C.UG_WINDOW)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_WINDOW) PassRef() (*C.UG_WINDOW, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2d7ddc5 != nil {
		return x.refe2d7ddc5, nil
	}
	meme2d7ddc5 := allocUG_WINDOWMemory(1)
	refe2d7ddc5 := (*C.UG_WINDOW)(meme2d7ddc5)
	allocse2d7ddc5 := new(cgoAllocMap)
	allocse2d7ddc5.Add(meme2d7ddc5)

	var cobjcnt_allocs *cgoAllocMap
	refe2d7ddc5.objcnt, cobjcnt_allocs = (C.UG_U8)(x.Objcnt), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cobjcnt_allocs)

	var cobjlst_allocs *cgoAllocMap
	refe2d7ddc5.objlst, cobjlst_allocs = unpackSUG_OBJECT(x.Objlst)
	allocse2d7ddc5.Borrow(cobjlst_allocs)

	var cstate_allocs *cgoAllocMap
	refe2d7ddc5.state, cstate_allocs = (C.UG_U8)(x.State), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cstate_allocs)

	var cfc_allocs *cgoAllocMap
	refe2d7ddc5.fc, cfc_allocs = (C.UG_COLOR)(x.Fc), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cfc_allocs)

	var cbc_allocs *cgoAllocMap
	refe2d7ddc5.bc, cbc_allocs = (C.UG_COLOR)(x.Bc), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cbc_allocs)

	var cxs_allocs *cgoAllocMap
	refe2d7ddc5.xs, cxs_allocs = (C.UG_S16)(x.Xs), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cxs_allocs)

	var cys_allocs *cgoAllocMap
	refe2d7ddc5.ys, cys_allocs = (C.UG_S16)(x.Ys), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cys_allocs)

	var cxe_allocs *cgoAllocMap
	refe2d7ddc5.xe, cxe_allocs = (C.UG_S16)(x.Xe), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cxe_allocs)

	var cye_allocs *cgoAllocMap
	refe2d7ddc5.ye, cye_allocs = (C.UG_S16)(x.Ye), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cye_allocs)

	var cstyle_allocs *cgoAllocMap
	refe2d7ddc5.style, cstyle_allocs = (C.UG_U8)(x.Style), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cstyle_allocs)

	var ctitle_allocs *cgoAllocMap
	refe2d7ddc5.title, ctitle_allocs = x.Title.PassValue()
	allocse2d7ddc5.Borrow(ctitle_allocs)

	var ccb_allocs *cgoAllocMap
	refe2d7ddc5.cb, ccb_allocs = x.Cb.PassValue()
	allocse2d7ddc5.Borrow(ccb_allocs)

	var cobjfcs_allocs *cgoAllocMap
	refe2d7ddc5.objfcs, cobjfcs_allocs = unpackSUG_OBJECT(x.Objfcs)
	allocse2d7ddc5.Borrow(cobjfcs_allocs)

	var cmovefcs_allocs *cgoAllocMap
	refe2d7ddc5.movefcs, cmovefcs_allocs = (C.UG_U8)(x.Movefcs), cgoAllocsUnknown
	allocse2d7ddc5.Borrow(cmovefcs_allocs)

	x.refe2d7ddc5 = refe2d7ddc5
	x.allocse2d7ddc5 = allocse2d7ddc5
	return refe2d7ddc5, allocse2d7ddc5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_WINDOW) PassValue() (C.UG_WINDOW, *cgoAllocMap) {
	if x.refe2d7ddc5 != nil {
		return *x.refe2d7ddc5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_WINDOW) Deref() {
	if x.refe2d7ddc5 == nil {
		return
	}
	x.Objcnt = (UG_U8)(x.refe2d7ddc5.objcnt)
	packSUG_OBJECT(x.Objlst, x.refe2d7ddc5.objlst)
	x.State = (UG_U8)(x.refe2d7ddc5.state)
	x.Fc = (UG_COLOR)(x.refe2d7ddc5.fc)
	x.Bc = (UG_COLOR)(x.refe2d7ddc5.bc)
	x.Xs = (UG_S16)(x.refe2d7ddc5.xs)
	x.Ys = (UG_S16)(x.refe2d7ddc5.ys)
	x.Xe = (UG_S16)(x.refe2d7ddc5.xe)
	x.Ye = (UG_S16)(x.refe2d7ddc5.ye)
	x.Style = (UG_U8)(x.refe2d7ddc5.style)
	x.Title = *NewUG_TITLERef(unsafe.Pointer(&x.refe2d7ddc5.title))
	x.Cb = *NewUG_Message_CallbackRef(unsafe.Pointer(&x.refe2d7ddc5.cb))
	packSUG_OBJECT(x.Objfcs, x.refe2d7ddc5.objfcs)
	x.Movefcs = (UG_U8)(x.refe2d7ddc5.movefcs)
}

// allocUG_AREAMemory allocates memory for type C.UG_AREA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_AREAMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_AREAValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_AREAValue = unsafe.Sizeof([1]C.UG_AREA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_AREA) Ref() *C.UG_AREA {
	if x == nil {
		return nil
	}
	return x.ref84da7460
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_AREA) Free() {
	if x != nil && x.allocs84da7460 != nil {
		x.allocs84da7460.(*cgoAllocMap).Free()
		x.ref84da7460 = nil
	}
}

// NewUG_AREARef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_AREARef(ref unsafe.Pointer) *UG_AREA {
	if ref == nil {
		return nil
	}
	obj := new(UG_AREA)
	obj.ref84da7460 = (*C.UG_AREA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_AREA) PassRef() (*C.UG_AREA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref84da7460 != nil {
		return x.ref84da7460, nil
	}
	mem84da7460 := allocUG_AREAMemory(1)
	ref84da7460 := (*C.UG_AREA)(mem84da7460)
	allocs84da7460 := new(cgoAllocMap)
	allocs84da7460.Add(mem84da7460)

	var cxs_allocs *cgoAllocMap
	ref84da7460.xs, cxs_allocs = (C.UG_S16)(x.Xs), cgoAllocsUnknown
	allocs84da7460.Borrow(cxs_allocs)

	var cys_allocs *cgoAllocMap
	ref84da7460.ys, cys_allocs = (C.UG_S16)(x.Ys), cgoAllocsUnknown
	allocs84da7460.Borrow(cys_allocs)

	var cxe_allocs *cgoAllocMap
	ref84da7460.xe, cxe_allocs = (C.UG_S16)(x.Xe), cgoAllocsUnknown
	allocs84da7460.Borrow(cxe_allocs)

	var cye_allocs *cgoAllocMap
	ref84da7460.ye, cye_allocs = (C.UG_S16)(x.Ye), cgoAllocsUnknown
	allocs84da7460.Borrow(cye_allocs)

	x.ref84da7460 = ref84da7460
	x.allocs84da7460 = allocs84da7460
	return ref84da7460, allocs84da7460

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_AREA) PassValue() (C.UG_AREA, *cgoAllocMap) {
	if x.ref84da7460 != nil {
		return *x.ref84da7460, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_AREA) Deref() {
	if x.ref84da7460 == nil {
		return
	}
	x.Xs = (UG_S16)(x.ref84da7460.xs)
	x.Ys = (UG_S16)(x.ref84da7460.ys)
	x.Xe = (UG_S16)(x.ref84da7460.xe)
	x.Ye = (UG_S16)(x.ref84da7460.ye)
}

// allocUG_TEXTMemory allocates memory for type C.UG_TEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_TEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_TEXTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_TEXTValue = unsafe.Sizeof([1]C.UG_TEXT{})

// unpackSUG_FONT transforms a sliced Go data structure into plain C format.
func unpackSUG_FONT(x []UG_FONT) (unpacked *C.UG_FONT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUG_FONTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.UG_FONT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.UG_FONT)(h.Data)
	return
}

// packSUG_FONT reads sliced Go data structure out from plain C format.
func packSUG_FONT(v []UG_FONT, ptr0 *C.UG_FONT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUG_FONTValue]C.UG_FONT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUG_FONTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_TEXT) Ref() *C.UG_TEXT {
	if x == nil {
		return nil
	}
	return x.ref68c5eecf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_TEXT) Free() {
	if x != nil && x.allocs68c5eecf != nil {
		x.allocs68c5eecf.(*cgoAllocMap).Free()
		x.ref68c5eecf = nil
	}
}

// NewUG_TEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_TEXTRef(ref unsafe.Pointer) *UG_TEXT {
	if ref == nil {
		return nil
	}
	obj := new(UG_TEXT)
	obj.ref68c5eecf = (*C.UG_TEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_TEXT) PassRef() (*C.UG_TEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref68c5eecf != nil {
		return x.ref68c5eecf, nil
	}
	mem68c5eecf := allocUG_TEXTMemory(1)
	ref68c5eecf := (*C.UG_TEXT)(mem68c5eecf)
	allocs68c5eecf := new(cgoAllocMap)
	allocs68c5eecf.Add(mem68c5eecf)

	var cstr_allocs *cgoAllocMap
	ref68c5eecf.str, cstr_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Str)), cgoAllocsUnknown
	allocs68c5eecf.Borrow(cstr_allocs)

	var cfont_allocs *cgoAllocMap
	ref68c5eecf.font, cfont_allocs = unpackSUG_FONT(x.Font)
	allocs68c5eecf.Borrow(cfont_allocs)

	var ca_allocs *cgoAllocMap
	ref68c5eecf.a, ca_allocs = x.A.PassValue()
	allocs68c5eecf.Borrow(ca_allocs)

	var cfc_allocs *cgoAllocMap
	ref68c5eecf.fc, cfc_allocs = (C.UG_COLOR)(x.Fc), cgoAllocsUnknown
	allocs68c5eecf.Borrow(cfc_allocs)

	var cbc_allocs *cgoAllocMap
	ref68c5eecf.bc, cbc_allocs = (C.UG_COLOR)(x.Bc), cgoAllocsUnknown
	allocs68c5eecf.Borrow(cbc_allocs)

	var calign_allocs *cgoAllocMap
	ref68c5eecf.align, calign_allocs = (C.UG_U8)(x.Align), cgoAllocsUnknown
	allocs68c5eecf.Borrow(calign_allocs)

	var ch_space_allocs *cgoAllocMap
	ref68c5eecf.h_space, ch_space_allocs = (C.UG_S16)(x.H_space), cgoAllocsUnknown
	allocs68c5eecf.Borrow(ch_space_allocs)

	var cv_space_allocs *cgoAllocMap
	ref68c5eecf.v_space, cv_space_allocs = (C.UG_S16)(x.V_space), cgoAllocsUnknown
	allocs68c5eecf.Borrow(cv_space_allocs)

	x.ref68c5eecf = ref68c5eecf
	x.allocs68c5eecf = allocs68c5eecf
	return ref68c5eecf, allocs68c5eecf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_TEXT) PassValue() (C.UG_TEXT, *cgoAllocMap) {
	if x.ref68c5eecf != nil {
		return *x.ref68c5eecf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_TEXT) Deref() {
	if x.ref68c5eecf == nil {
		return
	}
	x.Str = *(*[256]byte)(unsafe.Pointer(&x.ref68c5eecf.str))
	packSUG_FONT(x.Font, x.ref68c5eecf.font)
	x.A = *NewUG_AREARef(unsafe.Pointer(&x.ref68c5eecf.a))
	x.Fc = (UG_COLOR)(x.ref68c5eecf.fc)
	x.Bc = (UG_COLOR)(x.ref68c5eecf.bc)
	x.Align = (UG_U8)(x.ref68c5eecf.align)
	x.H_space = (UG_S16)(x.ref68c5eecf.h_space)
	x.V_space = (UG_S16)(x.ref68c5eecf.v_space)
}

// allocUG_BMPMemory allocates memory for type C.UG_BMP in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_BMPMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_BMPValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_BMPValue = unsafe.Sizeof([1]C.UG_BMP{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_BMP) Ref() *C.UG_BMP {
	if x == nil {
		return nil
	}
	return x.refc99e9a58
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_BMP) Free() {
	if x != nil && x.allocsc99e9a58 != nil {
		x.allocsc99e9a58.(*cgoAllocMap).Free()
		x.refc99e9a58 = nil
	}
}

// NewUG_BMPRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_BMPRef(ref unsafe.Pointer) *UG_BMP {
	if ref == nil {
		return nil
	}
	obj := new(UG_BMP)
	obj.refc99e9a58 = (*C.UG_BMP)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_BMP) PassRef() (*C.UG_BMP, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc99e9a58 != nil {
		return x.refc99e9a58, nil
	}
	memc99e9a58 := allocUG_BMPMemory(1)
	refc99e9a58 := (*C.UG_BMP)(memc99e9a58)
	allocsc99e9a58 := new(cgoAllocMap)
	allocsc99e9a58.Add(memc99e9a58)

	var cp_allocs *cgoAllocMap
	refc99e9a58.p, cp_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.P)), cgoAllocsUnknown
	allocsc99e9a58.Borrow(cp_allocs)

	var cwidth_allocs *cgoAllocMap
	refc99e9a58.width, cwidth_allocs = (C.UG_U16)(x.Width), cgoAllocsUnknown
	allocsc99e9a58.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refc99e9a58.height, cheight_allocs = (C.UG_U16)(x.Height), cgoAllocsUnknown
	allocsc99e9a58.Borrow(cheight_allocs)

	var cbpp_allocs *cgoAllocMap
	refc99e9a58.bpp, cbpp_allocs = (C.UG_U8)(x.Bpp), cgoAllocsUnknown
	allocsc99e9a58.Borrow(cbpp_allocs)

	var ccolors_allocs *cgoAllocMap
	refc99e9a58.colors, ccolors_allocs = (C.UG_U8)(x.Colors), cgoAllocsUnknown
	allocsc99e9a58.Borrow(ccolors_allocs)

	x.refc99e9a58 = refc99e9a58
	x.allocsc99e9a58 = allocsc99e9a58
	return refc99e9a58, allocsc99e9a58

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_BMP) PassValue() (C.UG_BMP, *cgoAllocMap) {
	if x.refc99e9a58 != nil {
		return *x.refc99e9a58, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_BMP) Deref() {
	if x.refc99e9a58 == nil {
		return
	}
	x.P = (unsafe.Pointer)(unsafe.Pointer(x.refc99e9a58.p))
	x.Width = (UG_U16)(x.refc99e9a58.width)
	x.Height = (UG_U16)(x.refc99e9a58.height)
	x.Bpp = (UG_U8)(x.refc99e9a58.bpp)
	x.Colors = (UG_U8)(x.refc99e9a58.colors)
}

// allocUG_MESSAGEMemory allocates memory for type C.UG_MESSAGE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_MESSAGEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_MESSAGEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_MESSAGEValue = unsafe.Sizeof([1]C.UG_MESSAGE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_MESSAGE) Ref() *C.UG_MESSAGE {
	if x == nil {
		return nil
	}
	return x.ref9ed6bbc5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_MESSAGE) Free() {
	if x != nil && x.allocs9ed6bbc5 != nil {
		x.allocs9ed6bbc5.(*cgoAllocMap).Free()
		x.ref9ed6bbc5 = nil
	}
}

// NewUG_MESSAGERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_MESSAGERef(ref unsafe.Pointer) *UG_MESSAGE {
	if ref == nil {
		return nil
	}
	obj := new(UG_MESSAGE)
	obj.ref9ed6bbc5 = (*C.UG_MESSAGE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_MESSAGE) PassRef() (*C.UG_MESSAGE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9ed6bbc5 != nil {
		return x.ref9ed6bbc5, nil
	}
	mem9ed6bbc5 := allocUG_MESSAGEMemory(1)
	ref9ed6bbc5 := (*C.UG_MESSAGE)(mem9ed6bbc5)
	allocs9ed6bbc5 := new(cgoAllocMap)
	allocs9ed6bbc5.Add(mem9ed6bbc5)

	var c_type_allocs *cgoAllocMap
	ref9ed6bbc5._type, c_type_allocs = (C.UG_U8)(x._type), cgoAllocsUnknown
	allocs9ed6bbc5.Borrow(c_type_allocs)

	var cid_allocs *cgoAllocMap
	ref9ed6bbc5.id, cid_allocs = (C.UG_U8)(x.Id), cgoAllocsUnknown
	allocs9ed6bbc5.Borrow(cid_allocs)

	var csub_id_allocs *cgoAllocMap
	ref9ed6bbc5.sub_id, csub_id_allocs = (C.UG_U8)(x.Sub_id), cgoAllocsUnknown
	allocs9ed6bbc5.Borrow(csub_id_allocs)

	var cevent_allocs *cgoAllocMap
	ref9ed6bbc5.event, cevent_allocs = (C.UG_U16)(x.Event), cgoAllocsUnknown
	allocs9ed6bbc5.Borrow(cevent_allocs)

	var cpos_x_allocs *cgoAllocMap
	ref9ed6bbc5.pos_x, cpos_x_allocs = (C.UG_U32)(x.Pos_x), cgoAllocsUnknown
	allocs9ed6bbc5.Borrow(cpos_x_allocs)

	var cpos_y_allocs *cgoAllocMap
	ref9ed6bbc5.pos_y, cpos_y_allocs = (C.UG_U32)(x.Pos_y), cgoAllocsUnknown
	allocs9ed6bbc5.Borrow(cpos_y_allocs)

	var csrc_allocs *cgoAllocMap
	ref9ed6bbc5.src, csrc_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Src)), cgoAllocsUnknown
	allocs9ed6bbc5.Borrow(csrc_allocs)

	x.ref9ed6bbc5 = ref9ed6bbc5
	x.allocs9ed6bbc5 = allocs9ed6bbc5
	return ref9ed6bbc5, allocs9ed6bbc5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_MESSAGE) PassValue() (C.UG_MESSAGE, *cgoAllocMap) {
	if x.ref9ed6bbc5 != nil {
		return *x.ref9ed6bbc5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_MESSAGE) Deref() {
	if x.ref9ed6bbc5 == nil {
		return
	}
	x._type = (UG_U8)(x.ref9ed6bbc5._type)
	x.Id = (UG_U8)(x.ref9ed6bbc5.id)
	x.Sub_id = (UG_U8)(x.ref9ed6bbc5.sub_id)
	x.Event = (UG_U16)(x.ref9ed6bbc5.event)
	x.Pos_x = (UG_U32)(x.ref9ed6bbc5.pos_x)
	x.Pos_y = (UG_U32)(x.ref9ed6bbc5.pos_y)
	x.Src = (unsafe.Pointer)(unsafe.Pointer(x.ref9ed6bbc5.src))
}

// allocUG_TOUCHMemory allocates memory for type C.UG_TOUCH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_TOUCHMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_TOUCHValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_TOUCHValue = unsafe.Sizeof([1]C.UG_TOUCH{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_TOUCH) Ref() *C.UG_TOUCH {
	if x == nil {
		return nil
	}
	return x.refc350cb41
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_TOUCH) Free() {
	if x != nil && x.allocsc350cb41 != nil {
		x.allocsc350cb41.(*cgoAllocMap).Free()
		x.refc350cb41 = nil
	}
}

// NewUG_TOUCHRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_TOUCHRef(ref unsafe.Pointer) *UG_TOUCH {
	if ref == nil {
		return nil
	}
	obj := new(UG_TOUCH)
	obj.refc350cb41 = (*C.UG_TOUCH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_TOUCH) PassRef() (*C.UG_TOUCH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc350cb41 != nil {
		return x.refc350cb41, nil
	}
	memc350cb41 := allocUG_TOUCHMemory(1)
	refc350cb41 := (*C.UG_TOUCH)(memc350cb41)
	allocsc350cb41 := new(cgoAllocMap)
	allocsc350cb41.Add(memc350cb41)

	var cstate_allocs *cgoAllocMap
	refc350cb41.state, cstate_allocs = (C.UG_U8)(x.State), cgoAllocsUnknown
	allocsc350cb41.Borrow(cstate_allocs)

	var cxp_allocs *cgoAllocMap
	refc350cb41.xp, cxp_allocs = (C.UG_S16)(x.Xp), cgoAllocsUnknown
	allocsc350cb41.Borrow(cxp_allocs)

	var cyp_allocs *cgoAllocMap
	refc350cb41.yp, cyp_allocs = (C.UG_S16)(x.Yp), cgoAllocsUnknown
	allocsc350cb41.Borrow(cyp_allocs)

	x.refc350cb41 = refc350cb41
	x.allocsc350cb41 = allocsc350cb41
	return refc350cb41, allocsc350cb41

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_TOUCH) PassValue() (C.UG_TOUCH, *cgoAllocMap) {
	if x.refc350cb41 != nil {
		return *x.refc350cb41, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_TOUCH) Deref() {
	if x.refc350cb41 == nil {
		return
	}
	x.State = (UG_U8)(x.refc350cb41.state)
	x.Xp = (UG_S16)(x.refc350cb41.xp)
	x.Yp = (UG_S16)(x.refc350cb41.yp)
}

func (x UG_OBJECT_UPDATE) PassRef() (ref *C.UG_OBJECT_UPDATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_OBJECT_UPDATE4EFEBDA8Func == nil {
		uG_OBJECT_UPDATE4EFEBDA8Func = x
	}
	return (*C.UG_OBJECT_UPDATE)(C.UG_OBJECT_UPDATE_4efebda8), nil
}

func (x UG_OBJECT_UPDATE) PassValue() (ref C.UG_OBJECT_UPDATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_OBJECT_UPDATE4EFEBDA8Func == nil {
		uG_OBJECT_UPDATE4EFEBDA8Func = x
	}
	return (C.UG_OBJECT_UPDATE)(C.UG_OBJECT_UPDATE_4efebda8), nil
}

func NewUG_OBJECT_UPDATERef(ref unsafe.Pointer) *UG_OBJECT_UPDATE {
	return (*UG_OBJECT_UPDATE)(ref)
}

//export uG_OBJECT_UPDATE4EFEBDA8
func uG_OBJECT_UPDATE4EFEBDA8(cArg0 *C.UG_WINDOW, cArg1 *C.UG_OBJECT) {
	if uG_OBJECT_UPDATE4EFEBDA8Func != nil {
		Arg04efebda8 := NewUG_WINDOWRef(unsafe.Pointer(cArg0))
		Arg14efebda8 := NewUG_OBJECTRef(unsafe.Pointer(cArg1))
		uG_OBJECT_UPDATE4EFEBDA8Func(Arg04efebda8, Arg14efebda8)
		return
	}
	panic("callback func has not been set (race?)")
}

var uG_OBJECT_UPDATE4EFEBDA8Func UG_OBJECT_UPDATE

// allocUG_TITLEMemory allocates memory for type C.UG_TITLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_TITLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_TITLEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_TITLEValue = unsafe.Sizeof([1]C.UG_TITLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_TITLE) Ref() *C.UG_TITLE {
	if x == nil {
		return nil
	}
	return x.ref1ed09ed8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_TITLE) Free() {
	if x != nil && x.allocs1ed09ed8 != nil {
		x.allocs1ed09ed8.(*cgoAllocMap).Free()
		x.ref1ed09ed8 = nil
	}
}

// NewUG_TITLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_TITLERef(ref unsafe.Pointer) *UG_TITLE {
	if ref == nil {
		return nil
	}
	obj := new(UG_TITLE)
	obj.ref1ed09ed8 = (*C.UG_TITLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_TITLE) PassRef() (*C.UG_TITLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1ed09ed8 != nil {
		return x.ref1ed09ed8, nil
	}
	mem1ed09ed8 := allocUG_TITLEMemory(1)
	ref1ed09ed8 := (*C.UG_TITLE)(mem1ed09ed8)
	allocs1ed09ed8 := new(cgoAllocMap)
	allocs1ed09ed8.Add(mem1ed09ed8)

	var cstr_allocs *cgoAllocMap
	ref1ed09ed8.str, cstr_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Str)), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cstr_allocs)

	var cfont_allocs *cgoAllocMap
	ref1ed09ed8.font, cfont_allocs = unpackSUG_FONT(x.Font)
	allocs1ed09ed8.Borrow(cfont_allocs)

	var ch_space_allocs *cgoAllocMap
	ref1ed09ed8.h_space, ch_space_allocs = (C.UG_S8)(x.H_space), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(ch_space_allocs)

	var cv_space_allocs *cgoAllocMap
	ref1ed09ed8.v_space, cv_space_allocs = (C.UG_S8)(x.V_space), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cv_space_allocs)

	var calign_allocs *cgoAllocMap
	ref1ed09ed8.align, calign_allocs = (C.UG_U8)(x.Align), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(calign_allocs)

	var cfc_allocs *cgoAllocMap
	ref1ed09ed8.fc, cfc_allocs = (C.UG_COLOR)(x.Fc), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cfc_allocs)

	var cbc_allocs *cgoAllocMap
	ref1ed09ed8.bc, cbc_allocs = (C.UG_COLOR)(x.Bc), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cbc_allocs)

	var cifc_allocs *cgoAllocMap
	ref1ed09ed8.ifc, cifc_allocs = (C.UG_COLOR)(x.Ifc), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cifc_allocs)

	var cibc_allocs *cgoAllocMap
	ref1ed09ed8.ibc, cibc_allocs = (C.UG_COLOR)(x.Ibc), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cibc_allocs)

	var cheight_allocs *cgoAllocMap
	ref1ed09ed8.height, cheight_allocs = (C.UG_U8)(x.Height), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cheight_allocs)

	var cprev_touch_px_allocs *cgoAllocMap
	ref1ed09ed8.prev_touch_px, cprev_touch_px_allocs = (C.UG_U8)(x.Prev_touch_px), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cprev_touch_px_allocs)

	var cprev_touch_py_allocs *cgoAllocMap
	ref1ed09ed8.prev_touch_py, cprev_touch_py_allocs = (C.UG_U8)(x.Prev_touch_py), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cprev_touch_py_allocs)

	var ctouch_state_allocs *cgoAllocMap
	ref1ed09ed8.touch_state, ctouch_state_allocs = (C.UG_U16)(x.Touch_state), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(ctouch_state_allocs)

	var cevent_allocs *cgoAllocMap
	ref1ed09ed8.event, cevent_allocs = (C.UG_U8)(x.Event), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cevent_allocs)

	var cdata_allocs *cgoAllocMap
	ref1ed09ed8.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs1ed09ed8.Borrow(cdata_allocs)

	x.ref1ed09ed8 = ref1ed09ed8
	x.allocs1ed09ed8 = allocs1ed09ed8
	return ref1ed09ed8, allocs1ed09ed8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_TITLE) PassValue() (C.UG_TITLE, *cgoAllocMap) {
	if x.ref1ed09ed8 != nil {
		return *x.ref1ed09ed8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_TITLE) Deref() {
	if x.ref1ed09ed8 == nil {
		return
	}
	x.Str = *(*[256]byte)(unsafe.Pointer(&x.ref1ed09ed8.str))
	packSUG_FONT(x.Font, x.ref1ed09ed8.font)
	x.H_space = (UG_S8)(x.ref1ed09ed8.h_space)
	x.V_space = (UG_S8)(x.ref1ed09ed8.v_space)
	x.Align = (UG_U8)(x.ref1ed09ed8.align)
	x.Fc = (UG_COLOR)(x.ref1ed09ed8.fc)
	x.Bc = (UG_COLOR)(x.ref1ed09ed8.bc)
	x.Ifc = (UG_COLOR)(x.ref1ed09ed8.ifc)
	x.Ibc = (UG_COLOR)(x.ref1ed09ed8.ibc)
	x.Height = (UG_U8)(x.ref1ed09ed8.height)
	x.Prev_touch_px = (UG_U8)(x.ref1ed09ed8.prev_touch_px)
	x.Prev_touch_py = (UG_U8)(x.ref1ed09ed8.prev_touch_py)
	x.Touch_state = (UG_U16)(x.ref1ed09ed8.touch_state)
	x.Event = (UG_U8)(x.ref1ed09ed8.event)
	x.Data = (unsafe.Pointer)(unsafe.Pointer(x.ref1ed09ed8.data))
}

func (x UG_Message_Callback) PassRef() (ref *C.UG_Message_Callback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_Message_Callback1FD3C4E6Func == nil {
		uG_Message_Callback1FD3C4E6Func = x
	}
	return (*C.UG_Message_Callback)(C.UG_Message_Callback_1fd3c4e6), nil
}

func (x UG_Message_Callback) PassValue() (ref C.UG_Message_Callback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_Message_Callback1FD3C4E6Func == nil {
		uG_Message_Callback1FD3C4E6Func = x
	}
	return (C.UG_Message_Callback)(C.UG_Message_Callback_1fd3c4e6), nil
}

func NewUG_Message_CallbackRef(ref unsafe.Pointer) *UG_Message_Callback {
	return (*UG_Message_Callback)(ref)
}

//export uG_Message_Callback1FD3C4E6
func uG_Message_Callback1FD3C4E6(cArg0 *C.UG_MESSAGE) {
	if uG_Message_Callback1FD3C4E6Func != nil {
		Arg01fd3c4e6 := NewUG_MESSAGERef(unsafe.Pointer(cArg0))
		uG_Message_Callback1FD3C4E6Func(Arg01fd3c4e6)
		return
	}
	panic("callback func has not been set (race?)")
}

var uG_Message_Callback1FD3C4E6Func UG_Message_Callback

// allocUG_BUTTONMemory allocates memory for type C.UG_BUTTON in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_BUTTONMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_BUTTONValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_BUTTONValue = unsafe.Sizeof([1]C.UG_BUTTON{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_BUTTON) Ref() *C.UG_BUTTON {
	if x == nil {
		return nil
	}
	return x.ref53358825
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_BUTTON) Free() {
	if x != nil && x.allocs53358825 != nil {
		x.allocs53358825.(*cgoAllocMap).Free()
		x.ref53358825 = nil
	}
}

// NewUG_BUTTONRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_BUTTONRef(ref unsafe.Pointer) *UG_BUTTON {
	if ref == nil {
		return nil
	}
	obj := new(UG_BUTTON)
	obj.ref53358825 = (*C.UG_BUTTON)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_BUTTON) PassRef() (*C.UG_BUTTON, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref53358825 != nil {
		return x.ref53358825, nil
	}
	mem53358825 := allocUG_BUTTONMemory(1)
	ref53358825 := (*C.UG_BUTTON)(mem53358825)
	allocs53358825 := new(cgoAllocMap)
	allocs53358825.Add(mem53358825)

	var cstate_allocs *cgoAllocMap
	ref53358825.state, cstate_allocs = (C.UG_U16)(x.State), cgoAllocsUnknown
	allocs53358825.Borrow(cstate_allocs)

	var cstyle_allocs *cgoAllocMap
	ref53358825.style, cstyle_allocs = (C.UG_U8)(x.Style), cgoAllocsUnknown
	allocs53358825.Borrow(cstyle_allocs)

	var cfc_allocs *cgoAllocMap
	ref53358825.fc, cfc_allocs = (C.UG_COLOR)(x.Fc), cgoAllocsUnknown
	allocs53358825.Borrow(cfc_allocs)

	var cbc_allocs *cgoAllocMap
	ref53358825.bc, cbc_allocs = (C.UG_COLOR)(x.Bc), cgoAllocsUnknown
	allocs53358825.Borrow(cbc_allocs)

	var cafc_allocs *cgoAllocMap
	ref53358825.afc, cafc_allocs = (C.UG_COLOR)(x.Afc), cgoAllocsUnknown
	allocs53358825.Borrow(cafc_allocs)

	var cabc_allocs *cgoAllocMap
	ref53358825.abc, cabc_allocs = (C.UG_COLOR)(x.Abc), cgoAllocsUnknown
	allocs53358825.Borrow(cabc_allocs)

	var cfont_allocs *cgoAllocMap
	ref53358825.font, cfont_allocs = unpackSUG_FONT(x.Font)
	allocs53358825.Borrow(cfont_allocs)

	var calign_allocs *cgoAllocMap
	ref53358825.align, calign_allocs = (C.UG_U8)(x.Align), cgoAllocsUnknown
	allocs53358825.Borrow(calign_allocs)

	var ch_space_allocs *cgoAllocMap
	ref53358825.h_space, ch_space_allocs = (C.UG_S8)(x.H_space), cgoAllocsUnknown
	allocs53358825.Borrow(ch_space_allocs)

	var cv_space_allocs *cgoAllocMap
	ref53358825.v_space, cv_space_allocs = (C.UG_S8)(x.V_space), cgoAllocsUnknown
	allocs53358825.Borrow(cv_space_allocs)

	var cstr_allocs *cgoAllocMap
	ref53358825.str, cstr_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Str)), cgoAllocsUnknown
	allocs53358825.Borrow(cstr_allocs)

	x.ref53358825 = ref53358825
	x.allocs53358825 = allocs53358825
	return ref53358825, allocs53358825

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_BUTTON) PassValue() (C.UG_BUTTON, *cgoAllocMap) {
	if x.ref53358825 != nil {
		return *x.ref53358825, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_BUTTON) Deref() {
	if x.ref53358825 == nil {
		return
	}
	x.State = (UG_U16)(x.ref53358825.state)
	x.Style = (UG_U8)(x.ref53358825.style)
	x.Fc = (UG_COLOR)(x.ref53358825.fc)
	x.Bc = (UG_COLOR)(x.ref53358825.bc)
	x.Afc = (UG_COLOR)(x.ref53358825.afc)
	x.Abc = (UG_COLOR)(x.ref53358825.abc)
	packSUG_FONT(x.Font, x.ref53358825.font)
	x.Align = (UG_U8)(x.ref53358825.align)
	x.H_space = (UG_S8)(x.ref53358825.h_space)
	x.V_space = (UG_S8)(x.ref53358825.v_space)
	x.Str = *(*[256]byte)(unsafe.Pointer(&x.ref53358825.str))
}

// allocUG_CHECKBOXMemory allocates memory for type C.UG_CHECKBOX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_CHECKBOXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_CHECKBOXValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_CHECKBOXValue = unsafe.Sizeof([1]C.UG_CHECKBOX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_CHECKBOX) Ref() *C.UG_CHECKBOX {
	if x == nil {
		return nil
	}
	return x.refe89193c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_CHECKBOX) Free() {
	if x != nil && x.allocse89193c != nil {
		x.allocse89193c.(*cgoAllocMap).Free()
		x.refe89193c = nil
	}
}

// NewUG_CHECKBOXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_CHECKBOXRef(ref unsafe.Pointer) *UG_CHECKBOX {
	if ref == nil {
		return nil
	}
	obj := new(UG_CHECKBOX)
	obj.refe89193c = (*C.UG_CHECKBOX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_CHECKBOX) PassRef() (*C.UG_CHECKBOX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe89193c != nil {
		return x.refe89193c, nil
	}
	meme89193c := allocUG_CHECKBOXMemory(1)
	refe89193c := (*C.UG_CHECKBOX)(meme89193c)
	allocse89193c := new(cgoAllocMap)
	allocse89193c.Add(meme89193c)

	var cstate_allocs *cgoAllocMap
	refe89193c.state, cstate_allocs = (C.UG_U8)(x.State), cgoAllocsUnknown
	allocse89193c.Borrow(cstate_allocs)

	var cstyle_allocs *cgoAllocMap
	refe89193c.style, cstyle_allocs = (C.UG_U8)(x.Style), cgoAllocsUnknown
	allocse89193c.Borrow(cstyle_allocs)

	var cfc_allocs *cgoAllocMap
	refe89193c.fc, cfc_allocs = (C.UG_COLOR)(x.Fc), cgoAllocsUnknown
	allocse89193c.Borrow(cfc_allocs)

	var cbc_allocs *cgoAllocMap
	refe89193c.bc, cbc_allocs = (C.UG_COLOR)(x.Bc), cgoAllocsUnknown
	allocse89193c.Borrow(cbc_allocs)

	var cafc_allocs *cgoAllocMap
	refe89193c.afc, cafc_allocs = (C.UG_COLOR)(x.Afc), cgoAllocsUnknown
	allocse89193c.Borrow(cafc_allocs)

	var cabc_allocs *cgoAllocMap
	refe89193c.abc, cabc_allocs = (C.UG_COLOR)(x.Abc), cgoAllocsUnknown
	allocse89193c.Borrow(cabc_allocs)

	var cfont_allocs *cgoAllocMap
	refe89193c.font, cfont_allocs = unpackSUG_FONT(x.Font)
	allocse89193c.Borrow(cfont_allocs)

	var calign_allocs *cgoAllocMap
	refe89193c.align, calign_allocs = (C.UG_U8)(x.Align), cgoAllocsUnknown
	allocse89193c.Borrow(calign_allocs)

	var ch_space_allocs *cgoAllocMap
	refe89193c.h_space, ch_space_allocs = (C.UG_S8)(x.H_space), cgoAllocsUnknown
	allocse89193c.Borrow(ch_space_allocs)

	var cv_space_allocs *cgoAllocMap
	refe89193c.v_space, cv_space_allocs = (C.UG_S8)(x.V_space), cgoAllocsUnknown
	allocse89193c.Borrow(cv_space_allocs)

	var cstr_allocs *cgoAllocMap
	refe89193c.str, cstr_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Str)), cgoAllocsUnknown
	allocse89193c.Borrow(cstr_allocs)

	var cchecked_allocs *cgoAllocMap
	refe89193c.checked, cchecked_allocs = (C.UG_U8)(x.Checked), cgoAllocsUnknown
	allocse89193c.Borrow(cchecked_allocs)

	x.refe89193c = refe89193c
	x.allocse89193c = allocse89193c
	return refe89193c, allocse89193c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_CHECKBOX) PassValue() (C.UG_CHECKBOX, *cgoAllocMap) {
	if x.refe89193c != nil {
		return *x.refe89193c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_CHECKBOX) Deref() {
	if x.refe89193c == nil {
		return
	}
	x.State = (UG_U8)(x.refe89193c.state)
	x.Style = (UG_U8)(x.refe89193c.style)
	x.Fc = (UG_COLOR)(x.refe89193c.fc)
	x.Bc = (UG_COLOR)(x.refe89193c.bc)
	x.Afc = (UG_COLOR)(x.refe89193c.afc)
	x.Abc = (UG_COLOR)(x.refe89193c.abc)
	packSUG_FONT(x.Font, x.refe89193c.font)
	x.Align = (UG_U8)(x.refe89193c.align)
	x.H_space = (UG_S8)(x.refe89193c.h_space)
	x.V_space = (UG_S8)(x.refe89193c.v_space)
	x.Str = *(*[256]byte)(unsafe.Pointer(&x.refe89193c.str))
	x.Checked = (UG_U8)(x.refe89193c.checked)
}

// allocUG_TEXTBOXMemory allocates memory for type C.UG_TEXTBOX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_TEXTBOXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_TEXTBOXValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_TEXTBOXValue = unsafe.Sizeof([1]C.UG_TEXTBOX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_TEXTBOX) Ref() *C.UG_TEXTBOX {
	if x == nil {
		return nil
	}
	return x.ref2f0e33f8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_TEXTBOX) Free() {
	if x != nil && x.allocs2f0e33f8 != nil {
		x.allocs2f0e33f8.(*cgoAllocMap).Free()
		x.ref2f0e33f8 = nil
	}
}

// NewUG_TEXTBOXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_TEXTBOXRef(ref unsafe.Pointer) *UG_TEXTBOX {
	if ref == nil {
		return nil
	}
	obj := new(UG_TEXTBOX)
	obj.ref2f0e33f8 = (*C.UG_TEXTBOX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_TEXTBOX) PassRef() (*C.UG_TEXTBOX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f0e33f8 != nil {
		return x.ref2f0e33f8, nil
	}
	mem2f0e33f8 := allocUG_TEXTBOXMemory(1)
	ref2f0e33f8 := (*C.UG_TEXTBOX)(mem2f0e33f8)
	allocs2f0e33f8 := new(cgoAllocMap)
	allocs2f0e33f8.Add(mem2f0e33f8)

	var cstr_allocs *cgoAllocMap
	ref2f0e33f8.str, cstr_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Str)), cgoAllocsUnknown
	allocs2f0e33f8.Borrow(cstr_allocs)

	var cfont_allocs *cgoAllocMap
	ref2f0e33f8.font, cfont_allocs = unpackSUG_FONT(x.Font)
	allocs2f0e33f8.Borrow(cfont_allocs)

	var cstyle_allocs *cgoAllocMap
	ref2f0e33f8.style, cstyle_allocs = (C.UG_U8)(x.Style), cgoAllocsUnknown
	allocs2f0e33f8.Borrow(cstyle_allocs)

	var cfc_allocs *cgoAllocMap
	ref2f0e33f8.fc, cfc_allocs = (C.UG_COLOR)(x.Fc), cgoAllocsUnknown
	allocs2f0e33f8.Borrow(cfc_allocs)

	var cbc_allocs *cgoAllocMap
	ref2f0e33f8.bc, cbc_allocs = (C.UG_COLOR)(x.Bc), cgoAllocsUnknown
	allocs2f0e33f8.Borrow(cbc_allocs)

	var calign_allocs *cgoAllocMap
	ref2f0e33f8.align, calign_allocs = (C.UG_U8)(x.Align), cgoAllocsUnknown
	allocs2f0e33f8.Borrow(calign_allocs)

	var ch_space_allocs *cgoAllocMap
	ref2f0e33f8.h_space, ch_space_allocs = (C.UG_S8)(x.H_space), cgoAllocsUnknown
	allocs2f0e33f8.Borrow(ch_space_allocs)

	var cv_space_allocs *cgoAllocMap
	ref2f0e33f8.v_space, cv_space_allocs = (C.UG_S8)(x.V_space), cgoAllocsUnknown
	allocs2f0e33f8.Borrow(cv_space_allocs)

	x.ref2f0e33f8 = ref2f0e33f8
	x.allocs2f0e33f8 = allocs2f0e33f8
	return ref2f0e33f8, allocs2f0e33f8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_TEXTBOX) PassValue() (C.UG_TEXTBOX, *cgoAllocMap) {
	if x.ref2f0e33f8 != nil {
		return *x.ref2f0e33f8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_TEXTBOX) Deref() {
	if x.ref2f0e33f8 == nil {
		return
	}
	x.Str = *(*[256]byte)(unsafe.Pointer(&x.ref2f0e33f8.str))
	packSUG_FONT(x.Font, x.ref2f0e33f8.font)
	x.Style = (UG_U8)(x.ref2f0e33f8.style)
	x.Fc = (UG_COLOR)(x.ref2f0e33f8.fc)
	x.Bc = (UG_COLOR)(x.ref2f0e33f8.bc)
	x.Align = (UG_U8)(x.ref2f0e33f8.align)
	x.H_space = (UG_S8)(x.ref2f0e33f8.h_space)
	x.V_space = (UG_S8)(x.ref2f0e33f8.v_space)
}

// allocUG_IMAGEMemory allocates memory for type C.UG_IMAGE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_IMAGEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_IMAGEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_IMAGEValue = unsafe.Sizeof([1]C.UG_IMAGE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_IMAGE) Ref() *C.UG_IMAGE {
	if x == nil {
		return nil
	}
	return x.reff0dbe2ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_IMAGE) Free() {
	if x != nil && x.allocsf0dbe2ec != nil {
		x.allocsf0dbe2ec.(*cgoAllocMap).Free()
		x.reff0dbe2ec = nil
	}
}

// NewUG_IMAGERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_IMAGERef(ref unsafe.Pointer) *UG_IMAGE {
	if ref == nil {
		return nil
	}
	obj := new(UG_IMAGE)
	obj.reff0dbe2ec = (*C.UG_IMAGE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_IMAGE) PassRef() (*C.UG_IMAGE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff0dbe2ec != nil {
		return x.reff0dbe2ec, nil
	}
	memf0dbe2ec := allocUG_IMAGEMemory(1)
	reff0dbe2ec := (*C.UG_IMAGE)(memf0dbe2ec)
	allocsf0dbe2ec := new(cgoAllocMap)
	allocsf0dbe2ec.Add(memf0dbe2ec)

	var cimg_allocs *cgoAllocMap
	reff0dbe2ec.img, cimg_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Img)), cgoAllocsUnknown
	allocsf0dbe2ec.Borrow(cimg_allocs)

	var c_type_allocs *cgoAllocMap
	reff0dbe2ec._type, c_type_allocs = (C.UG_U8)(x._type), cgoAllocsUnknown
	allocsf0dbe2ec.Borrow(c_type_allocs)

	x.reff0dbe2ec = reff0dbe2ec
	x.allocsf0dbe2ec = allocsf0dbe2ec
	return reff0dbe2ec, allocsf0dbe2ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_IMAGE) PassValue() (C.UG_IMAGE, *cgoAllocMap) {
	if x.reff0dbe2ec != nil {
		return *x.reff0dbe2ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_IMAGE) Deref() {
	if x.reff0dbe2ec == nil {
		return
	}
	x.Img = (unsafe.Pointer)(unsafe.Pointer(x.reff0dbe2ec.img))
	x._type = (UG_U8)(x.reff0dbe2ec._type)
}

// allocUG_DRIVERMemory allocates memory for type C.UG_DRIVER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_DRIVERMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_DRIVERValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_DRIVERValue = unsafe.Sizeof([1]C.UG_DRIVER{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_DRIVER) Ref() *C.UG_DRIVER {
	if x == nil {
		return nil
	}
	return x.ref785558c1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_DRIVER) Free() {
	if x != nil && x.allocs785558c1 != nil {
		x.allocs785558c1.(*cgoAllocMap).Free()
		x.ref785558c1 = nil
	}
}

// NewUG_DRIVERRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_DRIVERRef(ref unsafe.Pointer) *UG_DRIVER {
	if ref == nil {
		return nil
	}
	obj := new(UG_DRIVER)
	obj.ref785558c1 = (*C.UG_DRIVER)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_DRIVER) PassRef() (*C.UG_DRIVER, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref785558c1 != nil {
		return x.ref785558c1, nil
	}
	mem785558c1 := allocUG_DRIVERMemory(1)
	ref785558c1 := (*C.UG_DRIVER)(mem785558c1)
	allocs785558c1 := new(cgoAllocMap)
	allocs785558c1.Add(mem785558c1)

	var cdriver_allocs *cgoAllocMap
	ref785558c1.driver, cdriver_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Driver)), cgoAllocsUnknown
	allocs785558c1.Borrow(cdriver_allocs)

	var cstate_allocs *cgoAllocMap
	ref785558c1.state, cstate_allocs = (C.UG_U8)(x.State), cgoAllocsUnknown
	allocs785558c1.Borrow(cstate_allocs)

	x.ref785558c1 = ref785558c1
	x.allocs785558c1 = allocs785558c1
	return ref785558c1, allocs785558c1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_DRIVER) PassValue() (C.UG_DRIVER, *cgoAllocMap) {
	if x.ref785558c1 != nil {
		return *x.ref785558c1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_DRIVER) Deref() {
	if x.ref785558c1 == nil {
		return
	}
	x.Driver = (unsafe.Pointer)(unsafe.Pointer(x.ref785558c1.driver))
	x.State = (UG_U8)(x.ref785558c1.state)
}

func (x UG_GUI_PSET) PassRef() (ref *C.UG_GUI_PSET, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_GUI_PSET37BDED48Func == nil {
		uG_GUI_PSET37BDED48Func = x
	}
	return (*C.UG_GUI_PSET)(C.UG_GUI_PSET_37bded48), nil
}

func (x UG_GUI_PSET) PassValue() (ref C.UG_GUI_PSET, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_GUI_PSET37BDED48Func == nil {
		uG_GUI_PSET37BDED48Func = x
	}
	return (C.UG_GUI_PSET)(C.UG_GUI_PSET_37bded48), nil
}

func NewUG_GUI_PSETRef(ref unsafe.Pointer) *UG_GUI_PSET {
	return (*UG_GUI_PSET)(ref)
}

//export uG_GUI_PSET37BDED48
func uG_GUI_PSET37BDED48(cArg0 C.UG_S16, cArg1 C.UG_S16, cArg2 C.UG_COLOR) {
	if uG_GUI_PSET37BDED48Func != nil {
		Arg037bded48 := (UG_S16)(cArg0)
		Arg137bded48 := (UG_S16)(cArg1)
		Arg237bded48 := (UG_COLOR)(cArg2)
		uG_GUI_PSET37BDED48Func(Arg037bded48, Arg137bded48, Arg237bded48)
		return
	}
	panic("callback func has not been set (race?)")
}

var uG_GUI_PSET37BDED48Func UG_GUI_PSET

// allocUG_GUIMemory allocates memory for type C.UG_GUI in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUG_GUIMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUG_GUIValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUG_GUIValue = unsafe.Sizeof([1]C.UG_GUI{})

// unpackSUG_WINDOW transforms a sliced Go data structure into plain C format.
func unpackSUG_WINDOW(x []UG_WINDOW) (unpacked *C.UG_WINDOW, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUG_WINDOWMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.UG_WINDOW)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.UG_WINDOW)(h.Data)
	return
}

// allocA3UG_DRIVERMemory allocates memory for type [3]C.UG_DRIVER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA3UG_DRIVERMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA3UG_DRIVERValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA3UG_DRIVERValue = unsafe.Sizeof([1][3]C.UG_DRIVER{})

// unpackA3UG_DRIVER transforms a sliced Go data structure into plain C format.
func unpackA3UG_DRIVER(x [3]UG_DRIVER) (unpacked [3]C.UG_DRIVER, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA3UG_DRIVERMemory(1)
	allocs.Add(mem0)
	v0 := (*[3]C.UG_DRIVER)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[3]C.UG_DRIVER)(mem0)
	return
}

// packSUG_WINDOW reads sliced Go data structure out from plain C format.
func packSUG_WINDOW(v []UG_WINDOW, ptr0 *C.UG_WINDOW) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUG_WINDOWValue]C.UG_WINDOW)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUG_WINDOWRef(unsafe.Pointer(&ptr1))
	}
}

// packA3UG_DRIVER reads sliced Go data structure out from plain C format.
func packA3UG_DRIVER(v *[3]UG_DRIVER, ptr0 *[3]C.UG_DRIVER) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewUG_DRIVERRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UG_GUI) Ref() *C.UG_GUI {
	if x == nil {
		return nil
	}
	return x.ref2925682a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UG_GUI) Free() {
	if x != nil && x.allocs2925682a != nil {
		x.allocs2925682a.(*cgoAllocMap).Free()
		x.ref2925682a = nil
	}
}

// NewUG_GUIRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUG_GUIRef(ref unsafe.Pointer) *UG_GUI {
	if ref == nil {
		return nil
	}
	obj := new(UG_GUI)
	obj.ref2925682a = (*C.UG_GUI)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UG_GUI) PassRef() (*C.UG_GUI, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2925682a != nil {
		return x.ref2925682a, nil
	}
	mem2925682a := allocUG_GUIMemory(1)
	ref2925682a := (*C.UG_GUI)(mem2925682a)
	allocs2925682a := new(cgoAllocMap)
	allocs2925682a.Add(mem2925682a)

	var cpset_allocs *cgoAllocMap
	ref2925682a.pset, cpset_allocs = x.Pset.PassValue()
	allocs2925682a.Borrow(cpset_allocs)

	var cx_dim_allocs *cgoAllocMap
	ref2925682a.x_dim, cx_dim_allocs = (C.UG_S16)(x.X_dim), cgoAllocsUnknown
	allocs2925682a.Borrow(cx_dim_allocs)

	var cy_dim_allocs *cgoAllocMap
	ref2925682a.y_dim, cy_dim_allocs = (C.UG_S16)(x.Y_dim), cgoAllocsUnknown
	allocs2925682a.Borrow(cy_dim_allocs)

	var ctouch_allocs *cgoAllocMap
	ref2925682a.touch, ctouch_allocs = x.Touch.PassValue()
	allocs2925682a.Borrow(ctouch_allocs)

	var cnext_window_allocs *cgoAllocMap
	ref2925682a.next_window, cnext_window_allocs = unpackSUG_WINDOW(x.Next_window)
	allocs2925682a.Borrow(cnext_window_allocs)

	var cactive_window_allocs *cgoAllocMap
	ref2925682a.active_window, cactive_window_allocs = unpackSUG_WINDOW(x.Active_window)
	allocs2925682a.Borrow(cactive_window_allocs)

	var clast_window_allocs *cgoAllocMap
	ref2925682a.last_window, clast_window_allocs = unpackSUG_WINDOW(x.Last_window)
	allocs2925682a.Borrow(clast_window_allocs)

	var cfont_allocs *cgoAllocMap
	ref2925682a.font, cfont_allocs = x.Font.PassValue()
	allocs2925682a.Borrow(cfont_allocs)

	var cchar_h_space_allocs *cgoAllocMap
	ref2925682a.char_h_space, cchar_h_space_allocs = (C.UG_S8)(x.Char_h_space), cgoAllocsUnknown
	allocs2925682a.Borrow(cchar_h_space_allocs)

	var cchar_v_space_allocs *cgoAllocMap
	ref2925682a.char_v_space, cchar_v_space_allocs = (C.UG_S8)(x.Char_v_space), cgoAllocsUnknown
	allocs2925682a.Borrow(cchar_v_space_allocs)

	var cfore_color_allocs *cgoAllocMap
	ref2925682a.fore_color, cfore_color_allocs = (C.UG_COLOR)(x.Fore_color), cgoAllocsUnknown
	allocs2925682a.Borrow(cfore_color_allocs)

	var cback_color_allocs *cgoAllocMap
	ref2925682a.back_color, cback_color_allocs = (C.UG_COLOR)(x.Back_color), cgoAllocsUnknown
	allocs2925682a.Borrow(cback_color_allocs)

	var cdesktop_color_allocs *cgoAllocMap
	ref2925682a.desktop_color, cdesktop_color_allocs = (C.UG_COLOR)(x.Desktop_color), cgoAllocsUnknown
	allocs2925682a.Borrow(cdesktop_color_allocs)

	var cstate_allocs *cgoAllocMap
	ref2925682a.state, cstate_allocs = (C.UG_U8)(x.State), cgoAllocsUnknown
	allocs2925682a.Borrow(cstate_allocs)

	var cdriver_allocs *cgoAllocMap
	ref2925682a.driver, cdriver_allocs = unpackA3UG_DRIVER(x.Driver)
	allocs2925682a.Borrow(cdriver_allocs)

	var cfcs_move_allocs *cgoAllocMap
	ref2925682a.fcs_move, cfcs_move_allocs = (C.UG_U8)(x.Fcs_move), cgoAllocsUnknown
	allocs2925682a.Borrow(cfcs_move_allocs)

	var cfcs_press_allocs *cgoAllocMap
	ref2925682a.fcs_press, cfcs_press_allocs = (C.UG_U8)(x.Fcs_press), cgoAllocsUnknown
	allocs2925682a.Borrow(cfcs_press_allocs)

	x.ref2925682a = ref2925682a
	x.allocs2925682a = allocs2925682a
	return ref2925682a, allocs2925682a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UG_GUI) PassValue() (C.UG_GUI, *cgoAllocMap) {
	if x.ref2925682a != nil {
		return *x.ref2925682a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UG_GUI) Deref() {
	if x.ref2925682a == nil {
		return
	}
	x.Pset = *NewUG_GUI_PSETRef(unsafe.Pointer(&x.ref2925682a.pset))
	x.X_dim = (UG_S16)(x.ref2925682a.x_dim)
	x.Y_dim = (UG_S16)(x.ref2925682a.y_dim)
	x.Touch = *NewUG_TOUCHRef(unsafe.Pointer(&x.ref2925682a.touch))
	packSUG_WINDOW(x.Next_window, x.ref2925682a.next_window)
	packSUG_WINDOW(x.Active_window, x.ref2925682a.active_window)
	packSUG_WINDOW(x.Last_window, x.ref2925682a.last_window)
	x.Font = *NewUG_FONTRef(unsafe.Pointer(&x.ref2925682a.font))
	x.Char_h_space = (UG_S8)(x.ref2925682a.char_h_space)
	x.Char_v_space = (UG_S8)(x.ref2925682a.char_v_space)
	x.Fore_color = (UG_COLOR)(x.ref2925682a.fore_color)
	x.Back_color = (UG_COLOR)(x.ref2925682a.back_color)
	x.Desktop_color = (UG_COLOR)(x.ref2925682a.desktop_color)
	x.State = (UG_U8)(x.ref2925682a.state)
	packA3UG_DRIVER(&x.Driver, (*[3]C.UG_DRIVER)(unsafe.Pointer(&x.ref2925682a.driver)))
	x.Fcs_move = (UG_U8)(x.ref2925682a.fcs_move)
	x.Fcs_press = (UG_U8)(x.ref2925682a.fcs_press)
}

func (x UG_Init_Callback) PassRef() (ref *C.UG_Init_Callback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_Init_Callback19D8BB9FFunc == nil {
		uG_Init_Callback19D8BB9FFunc = x
	}
	return (*C.UG_Init_Callback)(C.UG_Init_Callback_19d8bb9f), nil
}

func (x UG_Init_Callback) PassValue() (ref C.UG_Init_Callback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uG_Init_Callback19D8BB9FFunc == nil {
		uG_Init_Callback19D8BB9FFunc = x
	}
	return (C.UG_Init_Callback)(C.UG_Init_Callback_19d8bb9f), nil
}

func NewUG_Init_CallbackRef(ref unsafe.Pointer) *UG_Init_Callback {
	return (*UG_Init_Callback)(ref)
}

//export uG_Init_Callback19D8BB9F
func uG_Init_Callback19D8BB9F(cArg0 C.UG_S16, cArg1 C.UG_S16, cArg2 C.UG_COLOR) {
	if uG_Init_Callback19D8BB9FFunc != nil {
		Arg019d8bb9f := (UG_S16)(cArg0)
		Arg119d8bb9f := (UG_S16)(cArg1)
		Arg219d8bb9f := (UG_COLOR)(cArg2)
		uG_Init_Callback19D8BB9FFunc(Arg019d8bb9f, Arg119d8bb9f, Arg219d8bb9f)
		return
	}
	panic("callback func has not been set (race?)")
}

var uG_Init_Callback19D8BB9FFunc UG_Init_Callback

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// unpackArgSUG_OBJECT transforms a sliced Go data structure into plain C format.
func unpackArgSUG_OBJECT(x []UG_OBJECT) (unpacked *C.UG_OBJECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUG_OBJECTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.UG_OBJECT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.UG_OBJECT)(h.Data)
	return
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
